#include <Arduino.h>
#include <Preferences.h>
#include "nvs_flash.h"

// HW181-MIC åˆ†è´æ£€æµ‹æ¨¡å—é…ç½®
#define SOUND_SENSOR_ANALOG_PIN 3 // æ¨¡æ‹Ÿè¾“å‡ºå¼•è„š (GPIO1 - ADC1_CH0)

// æµ‹è¯•å‚æ•°
unsigned long lastReadTime = 0;
const unsigned long READ_INTERVAL = 100; // 100msè¯»å–é—´éš”
unsigned long soundDetectedCount = 0;    // å£°éŸ³æ£€æµ‹è®¡æ•°
unsigned long totalReadings = 0;         // æ€»è¯»å–æ¬¡æ•°

// å£°éŸ³æ£€æµ‹å‚æ•° (åŸºäºä¿¡å·å˜åŒ–)
int lastAnalogValue = 0; // ä¸Šä¸€æ¬¡çš„æ¨¡æ‹Ÿå€¼

// ç”µå‹è½¬æ¢å‚æ•°
const float ADC_REF_VOLTAGE = 3.3; // ADCå‚è€ƒç”µå‹ (ESP32C3) (3.3V)
const int ADC_RESOLUTION = 4096;   // 12ä½ADCåˆ†è¾¨ç‡ (0-4095)

// ç”µå‹è½¬æ¢å‡½æ•°
float adcToVoltage(int adcValue)
{
  return (adcValue * ADC_REF_VOLTAGE) / ADC_RESOLUTION;
}

// æ ¡å‡†ç›¸å…³å˜é‡
bool calibrationMode = false;
int baselineValue = 0;
int calibrationCount = 0;
const int CALIBRATION_SAMPLES = 1200; // 1åˆ†é’Ÿæ ¡å‡† (1200 * 50ms = 60ç§’)

// Preferenceså­˜å‚¨æ–¹æ¡ˆ
Preferences preferences;

// è‡ªåŠ¨æ ¡å‡†å‚æ•°
bool isCalibrated = false;
int adaptiveChangeThreshold = 50; // è‡ªé€‚åº”å˜åŒ–é˜ˆå€¼

// åˆ†è´ä¼°ç®—ç›¸å…³å‚æ•°
const float MIN_DB = 30.0;              // æœ€å°åˆ†è´å€¼ (ç¯å¢ƒé™éŸ³)
const float MAX_DB = 120.0;             // æœ€å¤§åˆ†è´å€¼ (å¾ˆå“)
const float DB_RANGE = MAX_DB - MIN_DB; // åˆ†è´èŒƒå›´

// åˆ†è´è®¡ç®—å‚æ•° - æ ¹æ® HW181-MIC æ¨¡å—ç‰¹æ€§è°ƒæ•´
const float DB_BASELINE = 35.0;       // åŸºçº¿åˆ†è´å€¼ (ç¯å¢ƒå®‰é™æ—¶)
const float DB_SENSITIVITY = 25.0;    // åˆ†è´çµæ•åº¦ç³»æ•°
const float VOLTAGE_THRESHOLD = 0.01; // æœ€å°æœ‰æ•ˆç”µå‹

// åˆ†è´å¹³æ»‘æ»¤æ³¢
float lastDbValue = MIN_DB;
const float DB_SMOOTH_FACTOR = 0.7; // å¹³æ»‘ç³»æ•° (0-1)ï¼Œæé«˜çµæ•åº¦

// åˆ†è´ç»Ÿè®¡
float maxDbInPeriod = MIN_DB;
float minDbInPeriod = MAX_DB;
float avgDbSum = 0;
int dbSampleCount = 0;

// åˆ†è´è°ƒè¯•å‚æ•°
bool enableDbDebug = true; // å¯ç”¨è¯¦ç»†åˆ†è´è°ƒè¯•
unsigned long lastDbDebugTime = 0;
const unsigned long DB_DEBUG_INTERVAL = 2000; // æ¯2ç§’è¾“å‡ºè¯¦ç»†è°ƒè¯•ä¿¡æ¯

// å‡½æ•°å£°æ˜
void initNVS();
void initPreferences();
void loadCalibrationData();
void saveCalibrationData(int baseline, int threshold);
void performOneMinuteCalibration();
float calculateDecibels(int analogValue, float voltage);
float smoothDecibels(float currentDb, float lastDb, float smoothFactor);
void updateDecibelStatistics(float dbValue);
void printDecibelStatistics();

void setup()
{
  // åˆå§‹åŒ–ä¸²å£
  Serial.begin(115200);
  while (!Serial)
  {
    delay(10);
  }

  Serial.println("======================================");
  Serial.println("HW181-MC åˆ†è´æ£€æµ‹æ¨¡å—æµ‹è¯•ç¨‹åº (æ¨¡æ‹Ÿè¯»å–)");
  Serial.println("======================================");
  Serial.println("è¿æ¥ä¿¡æ¯:");
  Serial.println("- æ¨¡æ‹Ÿè¾“å‡º: GPIO1");
  Serial.println("- VCC: 5V");
  Serial.println("- GND: GND");
  Serial.println("======================================");

  // æ¨¡æ‹Ÿè¾“å…¥å¼•è„šä¸éœ€è¦é¢å¤–é…ç½®
  Serial.println("åˆå§‹åŒ–å®Œæˆï¼Œå¼€å§‹æµ‹è¯•...");
  Serial.println("è¯·åˆ¶é€ ä¸€äº›å£°éŸ³æ¥æµ‹è¯•ä¼ æ„Ÿå™¨!");
  Serial.println();

  delay(2000);

  // åˆå§‹åŒ–NVS
  initNVS();

  // åˆå§‹åŒ–Preferenceså­˜å‚¨
  initPreferences();

  // æ£€æŸ¥æ˜¯å¦éœ€è¦æ ¡å‡†
  if (!isCalibrated)
  {
    Serial.println("\nğŸ”§ æ£€æµ‹åˆ°é¦–æ¬¡ä½¿ç”¨ï¼Œå¼€å§‹è‡ªåŠ¨æ ¡å‡†...");
    Serial.println("è¯·ä¿æŒç¯å¢ƒå®‰é™ï¼Œæ ¡å‡†å°†æŒç»­1åˆ†é’Ÿ");
    Serial.println("æ ¡å‡†è¿‡ç¨‹ä¸­è¯·ä¸è¦åˆ¶é€ å£°éŸ³");
    delay(3000); // ç»™ç”¨æˆ·å‡†å¤‡æ—¶é—´

    performOneMinuteCalibration();
  }
}

void loop()
{
  unsigned long currentTime = millis();

  // æ¯100msè¯»å–ä¸€æ¬¡ä¼ æ„Ÿå™¨æ•°æ®
  if (currentTime - lastReadTime >= READ_INTERVAL)
  {
    lastReadTime = currentTime;
    totalReadings++;

    // è¯»å–æ¨¡æ‹Ÿè¾“å‡º (å£°éŸ³ä¿¡å·å¼ºåº¦)
    int analogValue = analogRead(SOUND_SENSOR_ANALOG_PIN);
    float voltage = adcToVoltage(analogValue);

    // è®¡ç®—åˆ†è´å€¼
    float currentDb = calculateDecibels(analogValue, voltage);
    float smoothedDb = smoothDecibels(currentDb, lastDbValue, DB_SMOOTH_FACTOR);
    lastDbValue = smoothedDb;

    // æ›´æ–°åˆ†è´ç»Ÿè®¡
    updateDecibelStatistics(smoothedDb);

    // è®¡ç®—ä¸ä¸Šä¸€æ¬¡è¯»æ•°çš„å˜åŒ–é‡
    int change = abs(analogValue - lastAnalogValue);
    bool soundDetected = (change > adaptiveChangeThreshold);

    if (soundDetected)
    {
      soundDetectedCount++;
      Serial.print("ğŸ”Š å£°éŸ³æ£€æµ‹! ");
    }
    else
    {
      Serial.print("ğŸ”‡ é™éŸ³çŠ¶æ€  ");
    }

    // è¾“å‡ºè¯¦ç»†ä¿¡æ¯ (åŒ…å«åˆ†è´)
    Serial.print("æ¨¡æ‹Ÿå€¼: ");
    Serial.print(analogValue);
    Serial.print(" (");
    Serial.print(voltage, 3); // æ˜¾ç¤º3ä½å°æ•°
    Serial.print("V) | ");
    Serial.print(smoothedDb, 1);
    Serial.print("dB | å˜åŒ–: ");
    Serial.print(change);
    Serial.print(" | é˜ˆå€¼: ");
    Serial.print(adaptiveChangeThreshold);
    Serial.print(" | è®¡æ•°: ");
    Serial.print(soundDetectedCount);
    Serial.print("/");
    Serial.println(totalReadings);

    // æ›´æ–°ä¸Šä¸€æ¬¡çš„å€¼
    lastAnalogValue = analogValue;

    // åˆ†è´è°ƒè¯•è¾“å‡º (æ¯2ç§’)
    if (enableDbDebug && (currentTime - lastDbDebugTime >= DB_DEBUG_INTERVAL))
    {
      lastDbDebugTime = currentTime;

      Serial.println();
      Serial.println("=== åˆ†è´è®¡ç®—è°ƒè¯•ä¿¡æ¯ ===");
      Serial.print("åŸå§‹æ¨¡æ‹Ÿå€¼: ");
      Serial.print(analogValue);
      Serial.print(" | åŸºçº¿å€¼: ");
      Serial.println(baselineValue);

      float baselineVoltage = adcToVoltage(baselineValue);
      Serial.print("å½“å‰ç”µå‹: ");
      Serial.print(voltage, 4);
      Serial.print("V | åŸºçº¿ç”µå‹: ");
      Serial.print(baselineVoltage, 4);
      Serial.println("V");

      Serial.print("ç”µå‹æ¯”å€¼: ");
      Serial.print(voltage / max(baselineVoltage, (float)0.001), 3);
      Serial.print(" | æ¨¡æ‹Ÿå€¼æ¯”å€¼: ");
      Serial.println((float)analogValue / max(baselineValue, 1), 3);

      Serial.print("ä¿¡å·å˜åŒ–: ");
      Serial.print(abs(analogValue - lastAnalogValue));
      Serial.print(" | å˜åŒ–é˜ˆå€¼: ");
      Serial.println(adaptiveChangeThreshold);

      Serial.print("è®¡ç®—åˆ†è´: ");
      Serial.print(currentDb, 2);
      Serial.print(" | å¹³æ»‘åˆ†è´: ");
      Serial.println(smoothedDb, 2);
      Serial.println("========================");
    }

    // æ¯10ç§’è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
    if (totalReadings % 100 == 0)
    {
      Serial.println();
      Serial.println("--- ç»Ÿè®¡ä¿¡æ¯ ---");
      Serial.print("æ€»æ£€æµ‹æ¬¡æ•°: ");
      Serial.println(totalReadings);
      Serial.print("å£°éŸ³æ£€æµ‹æ¬¡æ•°: ");
      Serial.println(soundDetectedCount);
      Serial.print("æ£€æµ‹ç‡: ");
      Serial.print((float)soundDetectedCount / totalReadings * 100, 2);
      Serial.println("%");

      // è¾“å‡ºå½“å‰æ¨¡æ‹Ÿå€¼èŒƒå›´åˆ†æ
      Serial.print("å½“å‰æ¨¡æ‹Ÿå€¼: ");
      Serial.print(analogValue);
      Serial.print(" (");
      Serial.print(voltage, 3);
      Serial.print("V, èŒƒå›´: 0-4095 / 0-3.3V)");
      Serial.println();

      // è¾“å‡ºåˆ†è´ç»Ÿè®¡
      printDecibelStatistics();

      // æ¨¡å—çŠ¶æ€è¯Šæ–­
      if (soundDetectedCount == 0)
      {
        Serial.println("âš ï¸  è­¦å‘Š: æœªæ£€æµ‹åˆ°ä»»ä½•å£°éŸ³å˜åŒ–!");
        Serial.println("   è¯·æ£€æŸ¥:");
        Serial.println("   1. è¿çº¿æ˜¯å¦æ­£ç¡®");
        Serial.println("   2. æ¨¡å—ä¾›ç”µæ˜¯å¦æ­£å¸¸");
        Serial.println("   3. æ¨¡å—çµæ•åº¦è®¾ç½®");
        Serial.println("   4. å˜åŒ–é˜ˆå€¼æ˜¯å¦åˆé€‚");
      }
      else if (soundDetectedCount == totalReadings)
      {
        Serial.println("âš ï¸  è­¦å‘Š: æŒç»­æ£€æµ‹åˆ°ä¿¡å·å˜åŒ–!");
        Serial.println("   å¯èƒ½åŸå› :");
        Serial.println("   1. ç¯å¢ƒå™ªéŸ³è¿‡å¤§");
        Serial.println("   2. æ¨¡å—çµæ•åº¦è¿‡é«˜");
        Serial.println("   3. å˜åŒ–é˜ˆå€¼è®¾ç½®è¿‡ä½");
        Serial.println("   4. ä¿¡å·ä¸ç¨³å®š");
      }
      else
      {
        Serial.println("âœ… æ¨¡å—å·¥ä½œæ­£å¸¸!");
      }
      Serial.println("==================");
      Serial.println();
    }
  }

  // éé˜»å¡å»¶è¿Ÿ
  delay(10);
}

// åˆå§‹åŒ–NVS
void initNVS()
{
  Serial.println("æ­£åœ¨åˆå§‹åŒ–NVSå­˜å‚¨ç³»ç»Ÿ...");

  esp_err_t err = nvs_flash_init();
  if (err == ESP_ERR_NVS_NO_FREE_PAGES || err == ESP_ERR_NVS_NEW_VERSION_FOUND)
  {
    // NVSåˆ†åŒºè¢«æˆªæ–­ï¼Œéœ€è¦æ“¦é™¤
    Serial.println("NVSåˆ†åŒºæŸåï¼Œæ­£åœ¨é‡æ–°åˆå§‹åŒ–...");
    ESP_ERROR_CHECK(nvs_flash_erase());
    err = nvs_flash_init();
  }

  if (err == ESP_OK)
  {
    Serial.println("âœ… NVSå­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–æˆåŠŸ");
  }
  else
  {
    Serial.print("âŒ NVSå­˜å‚¨ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥ï¼Œé”™è¯¯ä»£ç : ");
    Serial.println(err);
    Serial.println("å°†ä½¿ç”¨å†…å­˜å­˜å‚¨ï¼ˆæ•°æ®å°†åœ¨é‡å¯åä¸¢å¤±ï¼‰");
  }
}

// æ‰§è¡Œä¸€åˆ†é’Ÿæ ¡å‡†
void performOneMinuteCalibration()
{
  Serial.println("\nğŸ• å¼€å§‹1åˆ†é’ŸåŸºå‡†æ ¡å‡†...");

  calibrationMode = true;
  int totalSum = 0;
  int totalVariation = 0;
  int lastVal = analogRead(SOUND_SENSOR_ANALOG_PIN);
  calibrationCount = 0;

  unsigned long startTime = millis();
  unsigned long nextPrintTime = startTime + 10000; // æ¯10ç§’æ‰“å°è¿›åº¦

  // é‡‡é›†1åˆ†é’Ÿçš„æ•°æ®
  while (calibrationCount < CALIBRATION_SAMPLES)
  {
    delay(50); // æ¯50msé‡‡é›†ä¸€æ¬¡
    int analogVal = analogRead(SOUND_SENSOR_ANALOG_PIN);

    // è®¡ç®—åŸºçº¿å€¼
    totalSum += analogVal;

    // è®¡ç®—ä¿¡å·å˜åŒ–
    int variation = abs(analogVal - lastVal);
    totalVariation += variation;
    lastVal = analogVal;

    calibrationCount++;

    // æ‰“å°è¿›åº¦
    unsigned long currentTime = millis();
    if (currentTime >= nextPrintTime)
    {
      int progress = (calibrationCount * 100) / CALIBRATION_SAMPLES;
      Serial.print("æ ¡å‡†è¿›åº¦: ");
      Serial.print(progress);
      Serial.print("% (");
      Serial.print(calibrationCount);
      Serial.print("/");
      Serial.print(CALIBRATION_SAMPLES);
      Serial.println(")");
      nextPrintTime += 10000; // ä¸‹ä¸€ä¸ª10ç§’
    }
  }

  // è®¡ç®—æ ¡å‡†ç»“æœ
  baselineValue = totalSum / CALIBRATION_SAMPLES;
  int avgVariation = totalVariation / CALIBRATION_SAMPLES;
  adaptiveChangeThreshold = max(avgVariation * 3, 30); // è‡³å°‘30çš„é˜ˆå€¼

  float baselineVoltage = adcToVoltage(baselineValue);
  float thresholdVoltage = adcToVoltage(adaptiveChangeThreshold);

  // è®¡ç®—åŸºçº¿åˆ†è´
  float baselineDb = calculateDecibels(baselineValue, baselineVoltage);

  Serial.println("\nâœ… æ ¡å‡†å®Œæˆ!");
  Serial.print("åŸºçº¿å€¼: ");
  Serial.print(baselineValue);
  Serial.print(" (");
  Serial.print(baselineVoltage, 3);
  Serial.print("V, ");
  Serial.print(baselineDb, 1);
  Serial.println("dB)");
  Serial.print("å¹³å‡å˜åŒ–: ");
  Serial.println(avgVariation);
  Serial.print("è‡ªé€‚åº”é˜ˆå€¼: ");
  Serial.print(adaptiveChangeThreshold);
  Serial.print(" (");
  Serial.print(thresholdVoltage, 3);
  Serial.println("V)");

  // ä¿å­˜æ ¡å‡†æ•°æ®
  saveCalibrationData(baselineValue, adaptiveChangeThreshold);

  isCalibrated = true;
  calibrationMode = false;

  Serial.println("æ ¡å‡†æ•°æ®å·²ä¿å­˜ï¼Œç³»ç»Ÿå‡†å¤‡å°±ç»ª!");
  Serial.println("======================================");
}

// Preferencesåˆå§‹åŒ–
void initPreferences()
{
  Serial.println("æ­£åœ¨åˆå§‹åŒ–Preferenceså­˜å‚¨...");

  // æµ‹è¯•Preferencesæ˜¯å¦å¯ç”¨
  bool prefsOK = false;
  if (preferences.begin("hw181_test", false))
  {
    preferences.putString("test", "ok");
    String testResult = preferences.getString("test", "");
    preferences.end();

    if (testResult == "ok")
    {
      Serial.println("âœ… Preferenceså­˜å‚¨åˆå§‹åŒ–æˆåŠŸ");
      prefsOK = true;
    }
  }

  if (!prefsOK)
  {
    Serial.println("âŒ Preferenceså­˜å‚¨åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨å†…å­˜å­˜å‚¨");
    Serial.println("   æ³¨æ„: æ ¡å‡†æ•°æ®å°†åœ¨é‡å¯åä¸¢å¤±");
  }

  // åŠ è½½æ ¡å‡†æ•°æ®
  loadCalibrationData();
}

// ä¿å­˜æ ¡å‡†æ•°æ®åˆ°Preferences
void saveCalibrationData(int baseline, int threshold)
{
  Serial.println("æ­£åœ¨ä¿å­˜æ ¡å‡†æ•°æ®åˆ°Preferences...");

  if (preferences.begin("hw181_calib", false))
  {
    preferences.putInt("baseline", baseline);
    preferences.putInt("threshold", threshold);
    preferences.end();
    Serial.println("âœ… æ ¡å‡†æ•°æ®å·²ä¿å­˜åˆ°Preferences");
  }
  else
  {
    Serial.println("âŒ æ— æ³•ä¿å­˜æ ¡å‡†æ•°æ®åˆ°Preferences");
    Serial.println("   æ ¡å‡†æ•°æ®å°†ä¿å­˜åœ¨å†…å­˜ä¸­ï¼ˆé‡å¯åä¸¢å¤±ï¼‰");
  }
}

// ä»PreferencesåŠ è½½æ ¡å‡†æ•°æ®
void loadCalibrationData()
{
  if (preferences.begin("hw181_calib", true))
  { // åªè¯»æ¨¡å¼

    if (preferences.isKey("baseline") && preferences.isKey("threshold"))
    {
      baselineValue = preferences.getInt("baseline", 0);
      adaptiveChangeThreshold = preferences.getInt("threshold", 50);

      Serial.println("ğŸ“ å‘ç°æ ¡å‡†æ•°æ®ï¼Œæ­£åœ¨åŠ è½½...");
      Serial.print("âœ… æ ¡å‡†æ•°æ®åŠ è½½å®Œæˆ - åŸºçº¿å€¼: ");
      Serial.print(baselineValue);
      Serial.print(", é˜ˆå€¼: ");
      Serial.println(adaptiveChangeThreshold);
      isCalibrated = true;
    }
    else
    {
      Serial.println("ğŸ“ æœªå‘ç°æ ¡å‡†æ•°æ®ï¼Œéœ€è¦è¿›è¡Œé¦–æ¬¡æ ¡å‡†");
    }

    preferences.end();
  }
  else
  {
    Serial.println("ğŸ“ æ— æ³•è®¿é—®Preferenceså­˜å‚¨ï¼Œå°†ä½¿ç”¨é»˜è®¤è®¾ç½®");
    Serial.println("   éœ€è¦è¿›è¡Œé¦–æ¬¡æ ¡å‡†");
  }
}

// è®¡ç®—åˆ†è´å€¼
float calculateDecibels(int analogValue, float voltage)
{
  // æ”¹è¿›çš„åˆ†è´è®¡ç®—ç®—æ³•

  // é˜²æ­¢é™¤é›¶
  if (voltage < VOLTAGE_THRESHOLD)
    voltage = VOLTAGE_THRESHOLD;

  // æ–¹æ³•1: åŸºäºç”µå‹å˜åŒ–çš„åˆ†è´è®¡ç®—
  // ä½¿ç”¨ç›¸å¯¹äºåŸºçº¿ç”µå‹çš„å˜åŒ–æ¥è®¡ç®—åˆ†è´å¢é‡
  float baselineVoltage = adcToVoltage(baselineValue);
  if (baselineVoltage < VOLTAGE_THRESHOLD)
    baselineVoltage = VOLTAGE_THRESHOLD;

  // è®¡ç®—ç”µå‹æ¯”å€¼
  float voltageRatio = voltage / baselineVoltage;

  // ä½¿ç”¨å¯¹æ•°å…¬å¼: dB = åŸºçº¿dB + 20 * log10(V_current / V_baseline)
  float dbFromVoltage = DB_BASELINE + 20.0 * log10(voltageRatio);

  // æ–¹æ³•2: åŸºäºæ¨¡æ‹Ÿå€¼å˜åŒ–çš„çº¿æ€§æ˜ å°„
  float analogRatio = (float)analogValue / (float)max(baselineValue, 1);
  float dbFromAnalog = DB_BASELINE + DB_SENSITIVITY * (analogRatio - 1.0);

  // æ–¹æ³•3: åŸºäºä¿¡å·å˜åŒ–é‡çš„å¿«é€Ÿå“åº”
  int currentChange = abs(analogValue - lastAnalogValue);
  float changeBoost = 0;
  if (currentChange > adaptiveChangeThreshold)
  {
    // å½“æ£€æµ‹åˆ°æ˜æ˜¾å˜åŒ–æ—¶ï¼Œå¢åŠ åˆ†è´å“åº”
    changeBoost = 10.0 * (float)currentChange / (float)max(adaptiveChangeThreshold, 1);
    if (changeBoost > 30.0)
      changeBoost = 30.0; // é™åˆ¶æœ€å¤§å¢å¹…
  }

  // ç»“åˆä¸‰ç§æ–¹æ³•
  float calculatedDb = dbFromVoltage * 0.4 + dbFromAnalog * 0.4 + changeBoost * 0.2;

  // é™åˆ¶èŒƒå›´
  if (calculatedDb < MIN_DB)
    calculatedDb = MIN_DB;
  if (calculatedDb > MAX_DB)
    calculatedDb = MAX_DB;

  return calculatedDb;
}

// å¹³æ»‘åˆ†è´å€¼ (å‡å°‘è·³è·ƒä½†ä¿æŒæ•æ„Ÿæ€§)
float smoothDecibels(float currentDb, float lastDb, float smoothFactor)
{
  // å¦‚æœå˜åŒ–å¾ˆå¤§ï¼Œå‡å°‘å¹³æ»‘ä»¥ä¿æŒæ•æ„Ÿæ€§
  float dbDifference = abs(currentDb - lastDb);

  if (dbDifference > 5.0)
  {
    // å¤§å˜åŒ–æ—¶ï¼Œä½¿ç”¨æ›´é«˜çš„å“åº”åº¦
    smoothFactor = min(smoothFactor + 0.3, 1.0);
  }
  else if (dbDifference < 1.0)
  {
    // å°å˜åŒ–æ—¶ï¼Œä½¿ç”¨æ›´å¤šå¹³æ»‘
    smoothFactor = smoothFactor * 0.5;
  }

  return lastDb + smoothFactor * (currentDb - lastDb);
}

// æ›´æ–°åˆ†è´ç»Ÿè®¡
void updateDecibelStatistics(float dbValue)
{
  if (dbValue > maxDbInPeriod)
    maxDbInPeriod = dbValue;
  if (dbValue < minDbInPeriod)
    minDbInPeriod = dbValue;

  avgDbSum += dbValue;
  dbSampleCount++;
}

// æ‰“å°åˆ†è´ç»Ÿè®¡ä¿¡æ¯
void printDecibelStatistics()
{
  if (dbSampleCount > 0)
  {
    float avgDb = avgDbSum / dbSampleCount;

    Serial.print("ğŸ“Š åˆ†è´ç»Ÿè®¡ - å¹³å‡: ");
    Serial.print(avgDb, 1);
    Serial.print("dB | æœ€å¤§: ");
    Serial.print(maxDbInPeriod, 1);
    Serial.print("dB | æœ€å°: ");
    Serial.print(minDbInPeriod, 1);
    Serial.println("dB");

    // æ ¹æ®åˆ†è´çº§åˆ«ç»™å‡ºè¯„ä¼°
    if (avgDb < 40)
    {
      Serial.println("ğŸ”‡ ç¯å¢ƒ: å¾ˆå®‰é™ (å›¾ä¹¦é¦†çº§åˆ«)");
    }
    else if (avgDb < 50)
    {
      Serial.println("ğŸ  ç¯å¢ƒ: å®‰é™ (ä½å®…åŒº)");
    }
    else if (avgDb < 60)
    {
      Serial.println("ğŸ¢ ç¯å¢ƒ: æ­£å¸¸ (åŠå…¬å®¤)");
    }
    else if (avgDb < 70)
    {
      Serial.println("ğŸš— ç¯å¢ƒ: ç¨å˜ˆæ‚ (è¡—é“)");
    }
    else if (avgDb < 80)
    {
      Serial.println("ğŸ“¢ ç¯å¢ƒ: å˜ˆæ‚ (ç¹å¿™è¡—é“)");
    }
    else if (avgDb < 90)
    {
      Serial.println("ğŸš§ ç¯å¢ƒ: å¾ˆå˜ˆæ‚ (æ–½å·¥ç°åœº)");
    }
    else
    {
      Serial.println("âš ï¸ ç¯å¢ƒ: æå˜ˆæ‚ (å¯èƒ½æŸå®³å¬åŠ›)");
    }

    // é‡ç½®ç»Ÿè®¡
    maxDbInPeriod = MIN_DB;
    minDbInPeriod = MAX_DB;
    avgDbSum = 0;
    dbSampleCount = 0;
  }
}
